We have 128 cells. Each starts out with a probability of 1/128. Each has an index (range 0-127). A cell's index corresponds to the MIDI note that cell represents, and the probability will be recomputed in real time as the algorithm marches.

This array of size 128 whose cells all initially contain the float value of 1/128 will be called POSTERIOR. We are going to reassign the value of POSTERIOR according to this formula:

1. Understand that every element we look at in POSTERIOR, we view as if it were a tuple containing (MIDI, PROBABILITY)
2. For each of these tuples, we are running a comparison to every element of a second array whose size is also 128 but whose probabilities are different. This second map is called UIN_MAP
3. The PROBABILITY values for each element in the UIN_MAP array will be determined by a series of rules (described below)
4. The user will indicate a number of voices to allocate -- this number determines the number of times the comparison loop is run, and in between iterations of the comparison loop, the VOICING_MAP array will change (the VOICING_MAP is an array of 128 cells containing a 1 or a 0, and it affects the COMPUTE() function; in between iterations of the comparison loop, a random seed is generated and used to select an index from the probability distribution described by POSTERIOR; that index will be assigned a 1 in VOICING_MAP; if the number of voices the user says to allocate is greater than the number of voices already allocated, this process occurs for all the new notes, and then the old notes are freed up one at a time and rerolled until the full number of voices has been allocated; if the number the user indicated to allocate is equivalent or less than the number of voices already allocated, then those voices get freed up one at a time until the allocation quota has been reached, and any old voices still being held should be freed up once the quota is reached). 
5. The comparison loop iterates three times. The following describes the comparison loop: Each element j in POSTERIOR will be assigned to the sum of:
  for (i in UIN_MAP): i.PROBABILITY * COMPUTE(POSTERIOR.INDEX(j), i.INDEX) / POSTERIOR.PROBABILITY(j)

where COMPUTE() is a function which derives a single float value based on certain rules which will be described  below.

This is an implementation of Bayes's theorem -- P(A|B) = P(A) * P(B|A) / P(B). Here, "A" stands for the MIDI note in UIN_MAP being compared to, and "B" represents the MIDI note whose probability we're trying to determine. The probability of B given A -- that is, the PRIOR P(B|A) -- is a rule-based comparison of the two notes which returns a heuristic indicated the notes' harmonicity according to the user's indicated preference. In the first computation, this is a series of arithmetic compariosons -- but, in the second and third iteration of the comparison loop, the last POSTERIOR gets substituted into the formula as the PRIOR. The current probability of the cell in POSTERIOR which we are checking gets used to normalize the output, and the PRIOR is scaled by the raw probability of the value being compared against. at the end of the comparison loop, UIN_MAP is reassigned to copy POSTERIOR -- so, between comparison loops, the UIN_MAP and POSTERIOR arrays are identical, but while they are computing, the POSTERIOR array has its PROBABILITY values change during the iterations while the UIN_MAP remains unchanged. 


The rules that the COMPUTE() function uses are:
1. key -- The user specifies a key (by default, the key of C), and the probability of any "B" cell whose index lies outside of the MIDI major C scale values is automatically set to 0 and no future computations are run on it
2. fourths -- if a "B" cell's index is in the specified key and has a difference of value equating to 5 between a TRUE element's index in the VOICING_MAP array AND/OR has a difference of value equating to 5 between the "A" cell's index, COMPUTE()'s return value gets boosted by .3 (for example, if the B index is 65, the key is C, there is a 60 in VOICING_MAP, and the A index is 70, then COMPUTE()'s return value will increment by .6; however, if the A index was 71, it would only increment by .3, and if the A index was 70 but cell 60 in the VOICING_MAP array contained a 0 instead of a 1, COMPUTE()'s return value would only increment by .3)
3. fifths -- The same deal with the fourths rule, but the difference of value must be 7, and  COMPUTE()'s return value would only increment by .25
4. voice_leading -- if the difference between the B index and an allocated index in VOICING_MAP is either 1 or 2 and the B index in question is in the indicated key, COMPUTE()'s return value will increment by .2
